<!DOCTYPE html><html lang="en"><head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" sizes="512x512" href="assets/anvil-favicon.png">
  <title>Display</title>
  <!-- Force display window into passive mirror mode before any bundles run -->
  <script>
    try {
      // Mark as display explicitly (belt + suspenders)
      window.__TP_FORCE_DISPLAY = true;
      // Neuter any auto-scroll controllers that might boot in display context
      window.__tpAuto = {
        start() {},
        stop() {},
        set() {},
        setEnabled() {},
        setSpeed() {},
        startFromPreroll() {},
        isActive() { return false; },
        getState() { return { enabled: false, speed: 0 }; },
      };
      // Disable any local scroll writer so the main window remains the SSOT for movement
      window.__tpScrollWrite = {
        scrollTo() { /* display is mirror-only */ },
        scrollBy() { /* display is mirror-only */ },
      };
      // Freeze mode routing in display to manual so no local timers kick in
      window.__tpMode = {
        getMode: () => 'manual',
        get: () => 'manual',
        set: () => {},
        on: (fn) => { try { fn && fn('manual'); } catch {} return () => {}; },
      };
    } catch {}
  </script>
  <!-- TS bundle intentionally omitted in display window to keep it mirror-only and avoid double wiring -->
  <style>
          :root{--bg:#000;--fg:#e7ebf0;--edge:#1e2936;--muted:#96a0aa;--s1-color:#60a5fa;--s2-color:#facc15;--g1-color:#34d399;--g2-color:#f472b6}
          html,body{height:100%;margin:0;overflow:hidden}
          body{background:var(--bg);color:var(--fg);font:16px/1.5 system-ui}
          .wrap{height:100%;overflow:auto}
          /* Speaker colors (match main app defaults / CSS vars) */
          .speaker-s1{color:var(--s1-color,#60a5fa);font-weight:600;}
          .speaker-s2{color:var(--s2-color,#facc15);font-weight:600;}
          .speaker-guest1{color:var(--g1-color,#34d399);font-weight:600;}
          .speaker-guest2{color:var(--g2-color,#f472b6);font-weight:600;}

          /* Top bar legend (match main) */
          #displayTopbar{position:fixed;top:0;left:0;right:0;height:36px;display:flex;align-items:center;pointer-events:none;z-index:1000;padding:0 10px}
          .legend{display:flex;gap:8px;flex-wrap:wrap;margin-left:auto}
          .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid var(--edge);border-radius:999px;font-size:12px;background:#0e141b}
          .tag .dot{width:10px;height:10px;border-radius:50%}
          #displayTopbar{display:flex;align-items:center;justify-content:flex-start;gap:12px}
          #displayRecPill{display:inline-flex;align-items:center;gap:4px;padding:2px 10px;border-radius:999px;font-size:11px;font-weight:700;letter-spacing:.5px;border:1px solid rgba(255,255,255,.3);background:rgba(0,0,0,.6);color:#ffb3b3;text-transform:uppercase}
          #displayRecPill::before{content:'●';font-size:10px}
          #displayRecPill.hidden{display:none}
          #displayRecPill.armed{background:rgba(255,215,0,.18);color:#ffe28a}
          #displayRecPill.live{background:rgba(220,53,69,.35);color:#ffd6d6}
          /* Override to ensure bullet renders consistently */
          #displayRecPill::before{content:'\2022';font-size:10px}
          /* Rehearsal watermark (display) */
          html.tp-mode-rehearsal::before{
            content:'REHEARSAL';
            position:fixed;
            top:1rem;
            right:1rem;
            font-size:1.25rem;
            font-weight:600;
            padding:0.4rem 0.8rem;
            border-radius:999px;
            background:rgba(255,255,255,0.08);
            color:rgba(255,255,255,0.9);
            z-index:9999;
            pointer-events:none;
          }
          /* Match main app width and whitespace handling for identical wrapping */
          .script{
            max-width:900px;
            margin:0 auto;
            padding:0;
            white-space:pre-wrap;
            overflow-wrap:anywhere;
            word-break:break-word;
          }
          /* Match main app metrics exactly for consistent scroll physics */
          .script p{font-size:48px;line-height:1.35;margin:0 0 28px}
          .u{text-decoration:underline}
          .note{color:var(--muted);font-style:italic;margin:0 0 28px}
          /* Align with main marker at 40% */
          .marker{position:sticky;top:40%;height:2px;background:#7cc4ff;box-shadow:0 0 6px #7cc4ff}
          .hud{position:fixed;right:12px;bottom:12px;font:12px/1.2 system-ui;color:#9ba7b2;opacity:.7}
          #scrollLog{margin-top:8px;font-size:10px;text-align:left;max-width:300px;word-wrap:break-word;}
          .btn{cursor:pointer;border:1px solid var(--edge);padding:6px 8px;border-radius:8px;background:#0e141b;color:#e7ebf0;margin-left:8px}
          #preRoll{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:9999}
          #preRoll .card{background:#0e141b;border:1px solid var(--edge);padding:24px 32px;border-radius:16px;text-align:center}
          #preRoll .hint{font-size:14px;color:#9ba7b2}
          #preRoll .num{font-variant-numeric:tabular-nums;font-size:64px;line-height:1;margin-top:6px}
          /* CK watermark */
          body.ck::after{content:"CK";position:fixed;left:10px;bottom:10px;z-index:9999;font:600 11px/1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;letter-spacing:2px;color:#d67d2d;opacity:.18;pointer-events:none}
          /* Recorder pill overrides */
          #displayRecPill{all: unset; display:none;}
          .rec-pill{display:none;align-items:center;justify-content:center;height:22px;padding:0 12px;border-radius:999px;font-size:0.82rem;font-weight:700;letter-spacing:0.05em;text-transform:uppercase;line-height:1;opacity:0;transform:scale(.98);transition:opacity 500ms ease,transform 500ms ease,color 320ms ease,background-color 320ms ease;pointer-events:none;user-select:none}
          .rec-pill.is-visible{opacity:1;transform:scale(1)}
          .rec-pill.rec-pill--armed{background:#ffd54f;color:#1a1f27}
          .rec-pill.rec-pill--recording{background:#ef5350;color:#fff;animation:recPulse 2.5s ease-in-out infinite}
          .rec-pill--display{height:18px;padding:0 10px;font-size:11px}
          #displayRecPill::before{content:'\2022';font-size:10px;margin-right:6px}
          @keyframes recPulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.03);opacity:.95}100%{transform:scale(1);opacity:1}}
          /* Remote camera preview styles */
          #mirrorCamWrap{position:fixed;left:12px;bottom:12px;width:240px;max-width:28vw;z-index:1200;}
          #mirrorCamVideo{width:100%;max-width:100%;border:1px solid var(--edge);border-radius:12px;box-shadow:0 4px 18px -4px #000c;background:#000;display:block;}
          #mirrorCamLoading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font:12px system-ui;color:#9ba7b2;background:rgba(0,0,0,.55);border:1px solid var(--edge);border-radius:12px;-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);}
          /* === Typography vars and application (Pack A) === */
          :root{ --tp-font-size:56px; --tp-line-height:1.4; }
          #viewer .script .line,
          #viewer .script p,
          #wrap   .script .line,
          #wrap   .script p{
            font-size: var(--tp-font-size, 56px) !important;
            line-height: var(--tp-line-height, 1.4) !important;
            color: var(--tp-fg,#e6eef8);
            opacity: 1;
            display: block;
          }
          /* Responsive script column (main #viewer and display #wrap) */
          #viewer .script,
          #wrap   .script {
            margin-inline: auto;
            padding-inline: max(16px, 3vw);
            max-width: min(
              calc(var(--tp-maxch, 95) * 1ch),
              calc(100vw - 2 * max(16px, 3vw))
            );
          }
        </style></head>
        <body>
          <header id="displayTopbar">
              <div class="legend" id="legend"></div>
              <span id="displayRecPill" class="rec-pill rec-pill--display">REC</span>
          </header>
          <div class="wrap" id="wrap"><div class="marker"></div><div class="script" id="script"></div></div>
          <div class="hud">
            Display
            <button class="btn" id="flip">Flip</button>
            <button class="btn" id="invert">Invert</button>
            <button class="btn" id="camPiP" title="Toggle Picture-in-Picture for camera">PiP</button>
            <div id="scrollLog"></div>
          </div>
          <div id="mirrorCamWrap" hidden>
            <video id="mirrorCamVideo" autoplay muted></video>
            <div id="mirrorCamLoading">Connecting camera...</div>
          </div>
          <div id="preRoll"><div class="card"><div class="hint">Begin speaking in</div><div class="num" id="preRollNum">3</div></div></div>
          <script>
            // Expose our scroll root to the opener so main can target the right viewer
            try {
              const setOpenerRoot = () => {
                try {
                  if (window.opener && !window.opener.closed) {
                    const wrap = document.getElementById('wrap');
                    if (wrap) window.opener.__tpDisplayViewerEl = wrap;
                  }
                } catch {}
              };
              document.addEventListener('DOMContentLoaded', setOpenerRoot);
              // Also try again after a small delay to catch late-mount
              setTimeout(setOpenerRoot, 250);
            } catch {}
            const scriptEl = document.getElementById('script');
            const wrap = document.getElementById('wrap');
            const preRoll = document.getElementById('preRoll');
            const preRollNum = document.getElementById('preRollNum');

            // Speakers legend (display window)
            const legendEl = document.getElementById('legend');
            const legendState = {
              s1: { name: 'Joe', color: '#60a5fa' },
              s2: { name: 'Brad', color: '#facc15' },
            };
            const cssColor = (varName, fallback) => {
              try {
                const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
                return v || fallback;
              } catch { return fallback; }
            };
            function renderLegend() {
              if (!legendEl) return;
              legendEl.innerHTML = '';
              (['s1','s2']).forEach((key) => {
                const tag = document.createElement('span');
                tag.className = 'tag';
                const dot = document.createElement('span');
                dot.className = 'dot';
                dot.style.background = legendState[key].color || cssColor(`--${key}-color`, '#60a5fa');
                const lbl = document.createElement('span');
                lbl.id = `lbl-${key}`;
                lbl.textContent = legendState[key].name;
                tag.appendChild(dot);
                tag.appendChild(lbl);
                legendEl.appendChild(tag);
              });
            }
            renderLegend();

            // Color/name sync via BroadcastChannel
            let bc = null; try { bc = new BroadcastChannel('prompter'); } catch {}
            if (bc) {
              bc.onmessage = (e) => {
                const d = e?.data || {};
                if (d.type === 'SPEAKER_COLORS') {
                  if (d.s1) { document.documentElement.style.setProperty('--s1-color', d.s1); legendState.s1.color = d.s1; }
                  if (d.s2) { document.documentElement.style.setProperty('--s2-color', d.s2); legendState.s2.color = d.s2; }
                  renderLegend();
                } else if (d.type === 'SPEAKER_NAMES') {
                  if (typeof d.s1Name === 'string') { legendState.s1.name = d.s1Name; }
                  if (typeof d.s2Name === 'string') { legendState.s2.name = d.s2Name; }
                  renderLegend();
                }
              };
            }
            // TP: zoom-guard (display) + in-app Ctrl/Cmd + Wheel zoom
            try {
              window.addEventListener('wheel', (e)=>{
                try {
                  if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const step = 0.05;
                    nudgeScale(e.deltaY < 0 ? +step : -step);
                  }
                } catch {}
              }, { passive: false });
              window.addEventListener('keydown', (e)=>{
                if (e.ctrlKey || e.metaKey) {
                  const k = (e.key||'');
                  if (k === '+' || k === '=' || k === '-' || k === '_' || k === '0') e.preventDefault();
                }
              }, { capture:true });
            } catch {}
            // TP: display-typography-scale
            let baseFontSize = 48, baseLineHeight = 1.35;
            let dispScale = 1.0;
            try { const s = parseFloat(localStorage.getItem('tp_display_font_scale_v1')); if (isFinite(s) && s > 0.3 && s < 3) dispScale = s; } catch {}
            function applyBase(fs, lh){
              baseFontSize = Number(fs)||48; baseLineHeight = Number(lh)||1.35; applyScaled();
            }
            function applyScaled(){
              const fs = Math.max(8, Math.min(200, Math.round(baseFontSize * dispScale)));
              const lh = Math.max(1.1, Math.min(2.0, baseLineHeight));
              scriptEl.querySelectorAll('p,.note').forEach(p=>{ p.style.fontSize=fs+'px'; p.style.lineHeight=lh; });
            }
            function nudgeScale(delta){
              dispScale = Math.max(0.5, Math.min(2.5, Math.round((dispScale + delta) * 100) / 100));
              try { localStorage.setItem('tp_display_font_scale_v1', String(dispScale)); } catch {}
              applyScaled();
            }
            function flip(){ document.body.style.transform = document.body.style.transform ? '' : 'scaleX(-1)'; }
            function invert(){
              if(!document.body.dataset.inv){ document.body.dataset.inv=1; document.body.style.background = '#f4f7fb'; document.body.style.color = '#0b0d10'; }
              else { delete document.body.dataset.inv; document.body.style.background = '#000'; document.body.style.color = '#e7ebf0'; }
            }
            const camVid  = document.getElementById('mirrorCamVideo');
            try { if (camVid) { camVid.playsInline = true; camVid.setAttribute('playsinline',''); camVid.setAttribute('webkit-playsinline',''); } } catch {}
            const camWrap = document.getElementById('mirrorCamWrap');
            const camPiP  = document.getElementById('camPiP');
            const camLoad = document.getElementById('mirrorCamLoading');
            // PiP toggle
            if (camPiP) {
              camPiP.onclick = async () => {
                try {
                  if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                  } else if (camVid && camVid.requestPictureInPicture) {
                    await camVid.requestPictureInPicture();
                  }
                } catch {}
              };
            }
            // Dynamic bottom padding so the last paragraph can sit at the marker line
            function applyBottomPad(){
              try{
                const markerPct = (window.__TP_MARKER_PCT ?? 0.4);
                const vh = (wrap && wrap.clientHeight) || window.innerHeight || 800;
                const needForMarker = Math.floor(vh * markerPct) + 80; // cushion like main
                const basePad = Math.max(window.innerHeight * 0.55, 360);
                const pad = Math.max(basePad, needForMarker);
                if (scriptEl) scriptEl.style.paddingBottom = `${pad}px`;
              }catch{}
            }

            const recPill = document.getElementById('displayRecPill');
            function applyRecordState(state){
              if (!recPill) return;
              recPill.classList.remove('rec-pill--armed','rec-pill--recording','is-visible');
              recPill.style.display = 'none';
              recPill.setAttribute('aria-hidden','true');
              if (state === 'armed') {
                recPill.textContent = 'REC ARMED';
                recPill.classList.add('rec-pill--armed','is-visible');
                recPill.style.display = 'inline-flex';
                recPill.setAttribute('aria-hidden','false');
              } else if (state === 'recording') {
                recPill.textContent = 'REC';
                recPill.classList.add('rec-pill--recording','is-visible');
                recPill.style.display = 'inline-flex';
                recPill.setAttribute('aria-hidden','false');
              }
            }
            const mapRecState = (s) => (s === 'armed' ? 'armed' : s === 'recording' ? 'recording' : 'idle');

            // Call on resize (debounced 150ms; only adjust if focus changed)
            (function(){
              let startActive = null; let t = null;
              window.addEventListener('resize', () => {
                try {
                  if (t) clearTimeout(t);
                  if (!startActive) startActive = document.activeElement;
                  t = setTimeout(() => {
                    try {
                      const now = document.activeElement;
                      if (now !== startActive) applyBottomPad();
                    } catch {}
                    startActive = null;
                  }, 150);
                } catch {}
              }, { passive:true });
            })();

            // requestScroll: absolute pixels in the same container as viewer
            function requestScroll(value) {
              const max = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
              const targetTop = Math.max(0, Math.min(max, value | 0));
              wrap.scrollTop = targetTop;
              logScrollCommand(targetTop, wrap.scrollTop, targetTop - wrap.scrollTop, 'N/A', 'applied');
            }

            // Log scroll commands to HUD
            function logScrollCommand(cmdTop, curTop, delta, sim, status) {
              const logEl = document.getElementById('scrollLog');
              if (logEl) {
                const allowBack = status === 'allowed' && delta < 0 ? 'true' : status === 'blocked' ? 'false' : 'N/A';
                logEl.textContent = `cmdTop=${cmdTop}px | curTop=${curTop}px | Δ=${delta}px | sim=${sim} | allowBack?=${allowBack}`;
              }
            }

            // Compute marker offset onto the viewer (wrap) so lines align to marker without padding the script
            function applyMarkerOffset() {
              try {
                const markerPct = (window.__TP_MARKER_PCT ?? 0.4);
                const h = (wrap?.clientHeight || window.innerHeight || 0);
                const offset = Math.max(0, Math.round(h * markerPct));
                if (wrap) {
                  wrap.style.paddingTop = '0px';
                  wrap.style.scrollPaddingTop = `${offset}px`;
                  if (offset > h * 2) console.warn('[display][marker] insane offset', { offset, h });
                }
                if (scriptEl) {
                  scriptEl.style.paddingTop = `${offset}px`;
                  scriptEl.style.scrollPaddingTop = '0px';
                }
              } catch {}
            }

            // Render helper: accept either raw script text or already-rendered HTML with explicit format
            function applyScriptSnapshot(payload) {
              // 1) Compute marker offset on viewer
              applyMarkerOffset();

              // 2) Render script content
              try {
                if (!scriptEl) return;

                const fmt = (payload && payload.format) ? String(payload.format).toLowerCase() : '';
                const html = fmt === 'html' ? String(payload?.html || payload?.text || '') : '';
                const text = fmt === 'text' || !fmt ? String(payload?.text || '') : '';
                const source = html || text || '';

                const looksRendered = /<div[^>]+class=["']line\b/i.test(source);
                const looksHtml = fmt === 'html' || /<\/?[a-z][\s\S]*>/i.test(source);

                scriptEl.innerHTML = '';

                if (looksRendered || looksHtml) {
                  const cont = document.createElement('div');
                  cont.innerHTML = source || '';
                  while (cont.firstChild) scriptEl.appendChild(cont.firstChild);
                } else if (typeof window.renderScript === 'function') {
                  // Render locally; do not call opener to avoid re-entrant boot/loops
                  window.renderScript(source, scriptEl);
                } else {
                  const pre = document.createElement('pre');
                  pre.textContent = source;
                  scriptEl.appendChild(pre);
                }
              } catch (err) {
                try { console.warn('[display] applyScriptSnapshot failed', err); } catch {}
              }

              // 3) Ensure we start at the top (marker line)
              try { wrap?.scrollTo({ top: 0, behavior: 'auto' }); } catch {}
            }

            // Display-sync BroadcastChannel (minimal payloads with hash + optional full markup)
            try {
              const chan = new BroadcastChannel('tp_display');
              chan.addEventListener('message', (e) => {
                try {
                  const msg = e?.data || {};
                  // Script snapshots from main
                  if (msg && (msg.kind === 'tp:script' || msg.type === 'tp:script')) {
                    applyScriptSnapshot(msg);
                    applyScaled();
                    applyBottomPad();
                    return;
                  }
                  // Typography updates
                  if (msg && msg.kind === 'tp:typography') {
                    if (msg.fontSize && msg.lineHeight) {
                      applyBase(msg.fontSize, msg.lineHeight);
                    } else {
                      applyScaled();
                    }
                    applyBottomPad();
                    return;
                  }
                  if (msg && msg.kind === 'tp:record') {
                    applyRecordState(msg.state || 'idle');
                    return;
                  }
                  if (msg && msg.type === 'rec-state') {
                    applyRecordState(mapRecState(msg.state));
                    return;
                  }
                  // Lightweight mirror/diagnostic channel only
                  if (msg && msg.t === 'display:ping') {
                    try { chan.postMessage({ t: 'display:pong' }); } catch {}
                  }
                } catch {}
              });
            } catch {}

            window.addEventListener('message', ev => {
              const d = ev.data||{};
              // Scroll mirror: obey main window scroll commands
              if (d && d.type === 'scroll' && typeof d.top === 'number') {
                requestScroll(d.top);
                return;
              }
              // Script snapshots via postMessage
              if (d && (d.kind === 'tp:script' || d.type === 'tp:script')) {
                applyScriptSnapshot(d);
                applyScaled();
                applyBottomPad();
                if (typeof d.anchorRatio === 'number' && isFinite(d.anchorRatio)) {
                  const max = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
                  wrap.scrollTop = Math.round(Math.max(0, Math.min(1, d.anchorRatio)) * max);
                }
                return;
              }
              if (d && d.kind === 'tp:record') {
                applyRecordState(d.state || 'idle');
                return;
              }
              if (d && d.type === 'rec-state') {
                applyRecordState(mapRecState(d.state));
                return;
              }
              // Typography via postMessage
              if (d && d.kind === 'tp:typography') {
                try {
                  const s = document.documentElement.style;
                  const x = d.t || d || {};
                  if (x.fontFamily) s.setProperty('--tp-font-family', x.fontFamily);
                  if (x.fontSizePx != null) s.setProperty('--tp-font-size', String(x.fontSizePx) + 'px');
                  if (x.lineHeight != null) s.setProperty('--tp-line-height', String(x.lineHeight));
                  if (x.weight != null) s.setProperty('--tp-weight', String(x.weight));
                  if (x.letterSpacingEm != null) s.setProperty('--tp-letter-spacing', String(x.letterSpacingEm) + 'em');
                  if (x.wordSpacingEm != null) s.setProperty('--tp-word-spacing', String(x.wordSpacingEm) + 'em');
                  if (x.color) s.setProperty('--tp-fg', x.color);
                  if (x.background) s.setProperty('--tp-bg', x.background);
                  if (x.maxLineWidthCh != null) s.setProperty('--tp-maxch', String(x.maxLineWidthCh));
                  if (x.dimOthers != null) s.setProperty('--tp-dim', String(x.dimOthers));
                  if (x.fontSizePx != null || x.lineHeight != null) {
                    applyBase(x.fontSizePx, x.lineHeight);
                  }
                } catch {}
                applyScaled();
                applyBottomPad();
                return;
              }
              // New display-sync snapshot via postMessage fallback
              if (d && (d.kind === 'tp:script' || d.type === 'tp:script') && d.source === 'main') {
                try { window.__lastDisplayHash = d.textHash || ''; } catch {}
                const payload = String(d.html || d.text || '');
                if (payload) {
                  applyScriptSnapshot(payload);
                  applyScaled();
                  applyBottomPad();
                }
                if (typeof d.anchorRatio === 'number' && isFinite(d.anchorRatio)) {
                  const max = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
                  wrap.scrollTop = Math.round(Math.max(0, Math.min(1, d.anchorRatio)) * max);
                }
                return; // handled
              }
              // WebRTC camera offer/candidate handling
              if (!window.__camPC && (d.type === 'cam-offer')) {
                try {
                  const pc = new RTCPeerConnection({ iceServers: [] });
                  window.__camPC = pc;
                  pc.ontrack = (e) => {
                    if (camVid && e.streams && e.streams[0]) { camVid.srcObject = e.streams[0]; try { camVid.play().catch(()=>{}); } catch{} }
                  };
                  pc.onicecandidate = (e) => { if (e.candidate) { try { window.opener && window.opener.postMessage({ type:'cam-ice', candidate:e.candidate }, '*'); } catch {} } };
                  pc.setRemoteDescription({ type:'offer', sdp: d.sdp }).then(async ()=>{
                    const ans = await pc.createAnswer();
                    await pc.setLocalDescription(ans);
                    window.opener && window.opener.postMessage({ type:'cam-answer', sdp: ans.sdp }, '*');
                  });
                } catch (err) { console.warn('Display cam-offer handling failed', err); }
                return; // stop further processing of this message
              } else if (window.__camPC && d.type === 'cam-ice' && d.candidate) {
                try { window.__camPC.addIceCandidate(d.candidate); } catch {}
                return;
              }
              if (d && d.kind === 'tp:typography' && d.source === 'main' && d.display === 'display') {
                try {
                  const s = document.documentElement.style;
                  const x = d.t || {};
                  if (x.fontFamily) s.setProperty('--tp-font-family', x.fontFamily);
                  if (x.fontSizePx != null) s.setProperty('--tp-font-size', String(x.fontSizePx) + 'px');
                  if (x.lineHeight != null) s.setProperty('--tp-line-height', String(x.lineHeight));
                  if (x.weight != null) s.setProperty('--tp-weight', String(x.weight));
                  if (x.letterSpacingEm != null) s.setProperty('--tp-letter-spacing', String(x.letterSpacingEm) + 'em');
                  if (x.wordSpacingEm != null) s.setProperty('--tp-word-spacing', String(x.wordSpacingEm) + 'em');
                  if (x.color) s.setProperty('--tp-fg', x.color);
                  if (x.background) s.setProperty('--tp-bg', x.background);
                  if (x.maxLineWidthCh != null) s.setProperty('--tp-maxch', String(x.maxLineWidthCh));
                  if (x.dimOthers != null) s.setProperty('--tp-dim', String(x.dimOthers));
                  // Sync our base metrics for inline sizing
                  if (x.fontSizePx != null || x.lineHeight != null) {
                    applyBase(x.fontSizePx, x.lineHeight);
                  }
                } catch {}
                applyScaled();
                applyBottomPad();
                return;
              }
              if(d.type==='scroll'){
                // Guard against out-of-order scrolls using seq/ts if present
                try{
                  const seq = typeof d.seq === 'number' ? d.seq : 0;
                  const ts  = typeof d.ts === 'number' ? d.ts : 0;
                  const lastSeq = window.__dispLastSeq||0;
                  const lastTs  = window.__dispLastTs||0;
                  if (seq && (seq < lastSeq)) return; // older message
                  if (seq === lastSeq && ts && lastTs && ts < lastTs) return; // tie-break on ts
                  window.__dispLastSeq = seq || lastSeq;
                  window.__dispLastTs = ts || lastTs;
                } catch{}
                if (typeof d.top === 'number' && isFinite(d.top)) {
                  requestScroll(Math.max(0, d.top | 0));
                  return;
                }
                if (typeof d.ratio === 'number' && isFinite(d.ratio)){
                  const max = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
                  const absoluteValue = Math.round(d.ratio * max);
                  requestScroll(absoluteValue);
                  return;
                }
              }
              if(d.type==='preroll'){
                if(d.show){ preRoll.style.display='flex'; if(typeof d.n==='number') preRollNum.textContent=String(d.n); }
                else{ preRoll.style.display='none'; }
              }
              if(d.type==='toggle-ck'){
                document.body.classList.toggle('ck', !!d.on);
              }
            });
            document.getElementById('flip').onclick = flip;
            document.getElementById('invert').onclick = invert;
            const camPiPBtn = document.getElementById('camPiP');
            if (camPiPBtn){
              camPiPBtn.onclick = async () => {
                try {
                  const v = document.getElementById('mirrorCam');
                  if (!v) { showCamLoading('No camera'); return; }
                  if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                  } else if (v.requestPictureInPicture) {
                    await v.requestPictureInPicture();
                  }
                } catch (e){ console.warn('PiP failed', e); }
              };
            }
            window.addEventListener('keydown', (e)=>{
              const k = (e.key||'').toLowerCase();
              if (k === 'f'){ e.preventDefault(); flip(); }
              if (k === 'i'){ e.preventDefault(); invert(); }
              // In-app zoom for display only (Ctrl/Cmd + +/-/0)
              if (e.ctrlKey || e.metaKey){
                if (k === '+' || k === '='){ e.preventDefault(); nudgeScale(+0.05); }
                else if (k === '-' || k === '_'){ e.preventDefault(); nudgeScale(-0.05); }
                else if (k === '0'){ e.preventDefault(); dispScale = 1.0; try{ localStorage.setItem('tp_display_font_scale_v1','1'); }catch{} applyScaled(); }
              }
            });
            // Rehearsal Mode mirror: apply tint + watermark listener
            try {
              function applyRehearsalDisplay(active){
                try {
                  document.body.classList.toggle('is-rehearsal-display', !!active);
                  // Soft visual cue distinct from main watermark
                  if (active) {
                    if (!document.getElementById('rehearsalDisplayWatermark')){
                      const w = document.createElement('div');
                      w.id='rehearsalDisplayWatermark';
                      w.style.cssText='position:fixed;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center;z-index:9999;font:700 clamp(20px,6vw,60px)/1 system-ui;color:#fff;opacity:.06;letter-spacing:.15em;text-transform:uppercase;';
                      w.textContent='REHEARSAL';
                      document.body.appendChild(w);
                    }
                  }
                } catch {}
              }
              // Initial state (if main already set flag before spawn)
              try { applyRehearsalDisplay(window.opener && window.opener.__TP_REHEARSAL); } catch {}
              window.addEventListener('message', (ev)=>{
                try {
                  if (ev && ev.data === 'tp:rehearsal:start') applyRehearsalDisplay(true);
                  else if (ev && ev.data === 'tp:rehearsal:stop') applyRehearsalDisplay(false);
                } catch {}
              });
              // BroadcastChannel mirror (in case direct postMessage missed)
              try {
                const rchan = new BroadcastChannel('tp_rehearsal');
                rchan.addEventListener('message', (e)=>{
                  try {
                    if (e?.data?.t === 'rehearsal' && typeof e.data.on === 'boolean') {
                      applyRehearsalDisplay(!!e.data.on);
                    }
                  } catch {}
                });
              } catch {}
            } catch {}
          </script>
        </body></html>
