<script>
  // … your existing code …
  document.addEventListener('DOMContentLoaded', function() {
    window.opener && window.opener.postMessage('DISPLAY_READY', '*');
  });
</script>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Display</title>
  <style>
          :root{--bg:#000;--fg:#e7ebf0;--edge:#1e2936;--muted:#96a0aa;--s1-color:#2ea8ff;--s2-color:#ff6b6b}
          html,body{height:100%}
          body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.5 system-ui}
          .wrap{height:100%;overflow:auto}
          /* Top bar legend */
          #displayTopbar{position:fixed;top:0;left:0;right:0;height:36px;display:flex;align-items:center;pointer-events:none;z-index:1000;padding:0 10px}
          #legend{display:flex;gap:14px;align-items:center;font-size:12px;opacity:.95;margin-left:4px;background:rgba(14,20,27,.72);border:1px solid var(--edge);padding:4px 8px;border-radius:999px}
          #legend .dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:6px;box-shadow:0 0 4px rgba(0,0,0,.3)}
          #legend .lbl{font-size:12px;color:var(--muted);margin-right:10px}
          #legend .dot.s1{background:var(--s1-color)}
          #legend .dot.s2{background:var(--s2-color)}
          /* Match main app width for identical wrapping */
          .script{max-width:900px;margin:0 auto;padding:40px}
          /* Match main app metrics exactly for consistent scroll physics */
          .script p{font-size:48px;line-height:1.35;margin:0 0 28px}
          .u{text-decoration:underline}
          .note{color:var(--muted);font-style:italic;margin:0 0 28px}
          /* Align with main marker at 40% */
          .marker{position:sticky;top:40%;height:2px;background:#7cc4ff;box-shadow:0 0 6px #7cc4ff}
          .hud{position:fixed;right:12px;bottom:12px;font:12px/1.2 system-ui;color:#9ba7b2;opacity:.7}
          .btn{cursor:pointer;border:1px solid var(--edge);padding:6px 8px;border-radius:8px;background:#0e141b;color:#e7ebf0;margin-left:8px}
          #preRoll{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:9999}
          #preRoll .card{background:#0e141b;border:1px solid var(--edge);padding:24px 32px;border-radius:16px;text-align:center}
          #preRoll .hint{font-size:14px;color:#9ba7b2}
          #preRoll .num{font-variant-numeric:tabular-nums;font-size:64px;line-height:1;margin-top:6px}
          /* CK watermark */
          body.ck::after{content:"CK";position:fixed;left:10px;bottom:10px;z-index:9999;font:600 11px/1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;letter-spacing:2px;color:#d67d2d;opacity:.18;pointer-events:none}
          /* Remote camera preview styles */
          #mirrorCamWrap{position:fixed;left:12px;bottom:12px;width:240px;max-width:28vw;z-index:1200;}
          #mirrorCamVideo{width:100%;max-width:100%;border:1px solid var(--edge);border-radius:12px;box-shadow:0 4px 18px -4px #000c;background:#000;display:block;}
          #mirrorCamLoading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font:12px system-ui;color:#9ba7b2;background:rgba(0,0,0,.55);border:1px solid var(--edge);border-radius:12px;-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);}
        </style></head>
        <body>
          <header id="displayTopbar">
            <div id="legend">
              <span class="dot s1"></span><span class="lbl" id="lbl-s1">Joe</span>
              <span class="dot s2"></span><span class="lbl" id="lbl-s2">Brad</span>
            </div>
          </header>
          <div class="wrap" id="wrap"><div class="marker" id="marker-line"></div><div class="script" id="script"></div></div>
          <div class="hud">Display <button class="btn" id="flip">Flip</button> <button class="btn" id="invert">Invert</button> <button class="btn" id="camPiP" title="Toggle Picture-in-Picture for camera">PiP</button></div>
          <div id="mirrorCamWrap" hidden>
            <video id="mirrorCamVideo" autoplay muted></video>
            <div id="mirrorCamLoading">Connecting camera…</div>
          </div>
          <div id="preRoll"><div class="card"><div class="hint">Begin speaking in</div><div class="num" id="preRollNum">3</div></div></div>
          <script>
            // ---------- measurement helpers (display) ----------
            function getScroller(doc, win) {
              // Use a specific scroller if present; fall back to the window viewport
              return doc.querySelector('#displayScroll') || doc.getElementById('wrap') || win;
            }
            function relTop(el, scroller, win) {
              const r = el.getBoundingClientRect();
              const baseTop = (scroller === win ? 0 : scroller.getBoundingClientRect().top);
              return r.top - baseTop;
            }
            function relBottom(el, scroller, win) {
              const r = el.getBoundingClientRect();
              const baseTop = (scroller === win ? 0 : scroller.getBoundingClientRect().top);
              return r.bottom - baseTop;
            }
            function getScrollTop(scroller, win) {
              return (scroller === win) ? win.scrollY : scroller.scrollTop;
            }
            function setScrollTop(scroller, win, y) {
              if (scroller === win) win.scrollTo(0, y);
              else scroller.scrollTop = y;
            }
            function maxScrollTop(scroller, win, doc) {
              const h = (scroller === win ? doc.scrollingElement.scrollHeight : scroller.scrollHeight);
              const vh = (scroller === win ? win.innerHeight : scroller.clientHeight);
              return Math.max(0, h - vh);
            }
            const scriptEl = document.getElementById('script');
            const wrap = document.getElementById('wrap');
            const preRoll = document.getElementById('preRoll');
            const preRollNum = document.getElementById('preRollNum');
            // Display: ensure last lines can reach marker by adding a bottom spacer sized to markerY
            function updateEndSpacer(){
              try {
                const scroller = getScroller(document, window);
                const marker = document.getElementById('marker-line');
                if (!marker || !scriptEl || !scroller) return;
                const markerY = relTop(marker, scroller, window);
                ensureEndSpacer(document, scroller, window, markerY);
                // ensure spacer is under #script
                const spacer = document.getElementById('end-spacer');
                if (spacer && spacer.parentElement !== scriptEl) scriptEl.appendChild(spacer);
              } catch {}
            }
            function ensureEndSpacer(doc, scroller, win, markerY, padExtra = 8){
              try {
                const V = (scroller === win ? win.innerHeight : scroller.clientHeight) || 0;
                const pad = Math.max(0, Math.ceil((V - Number(markerY || 0)) + Number(padExtra)));
                let spacer = doc.getElementById('end-spacer');
                if (!spacer) {
                  spacer = doc.createElement('div');
                  spacer.id = 'end-spacer';
                  spacer.setAttribute('aria-hidden','true');
                  spacer.style.pointerEvents = 'none';
                  (doc.querySelector('#script') || doc.body).appendChild(spacer);
                }
                spacer.style.height = pad + 'px';
              } catch {}
            }
            // Color sync via BroadcastChannel
            let bc = null; try { bc = new BroadcastChannel('prompter'); } catch {}
            if (bc) {
              const lblS1 = () => document.getElementById('lbl-s1');
              const lblS2 = () => document.getElementById('lbl-s2');
              bc.onmessage = (e) => {
                const d = e?.data || {};
                if (d.type === 'SPEAKER_COLORS') {
                  if (d.s1) document.documentElement.style.setProperty('--s1-color', d.s1);
                  if (d.s2) document.documentElement.style.setProperty('--s2-color', d.s2);
                } else if (d.type === 'SPEAKER_NAMES') {
                  if (typeof d.s1Name === 'string') { const n = lblS1(); if (n) n.textContent = d.s1Name; }
                  if (typeof d.s2Name === 'string') { const n = lblS2(); if (n) n.textContent = d.s2Name; }
                }
              };
            }
            // TP: zoom-guard (display)
            try {
              window.addEventListener('wheel', (e)=>{ if (e.ctrlKey || e.metaKey) e.preventDefault(); }, { passive: false });
              window.addEventListener('keydown', (e)=>{
                if (e.ctrlKey || e.metaKey) {
                  const k = (e.key||'');
                  if (k === '+' || k === '=' || k === '-' || k === '_' || k === '0') e.preventDefault();
                }
              }, { capture:true });
            } catch {}
            // TP: display-typography-scale
            let baseFontSize = 48, baseLineHeight = 1.35;
            let dispScale = 1.0;
            try { const s = parseFloat(localStorage.getItem('tp_display_font_scale_v1')); if (isFinite(s) && s > 0.3 && s < 3) dispScale = s; } catch {}
            function applyBase(fs, lh){
              baseFontSize = Number(fs)||48; baseLineHeight = Number(lh)||1.35; applyScaled();
            }
            function applyScaled(){
              const fs = Math.max(8, Math.min(200, Math.round(baseFontSize * dispScale)));
              const lh = Math.max(1.1, Math.min(2.0, baseLineHeight));
              scriptEl.querySelectorAll('p,.note').forEach(p=>{ p.style.fontSize=fs+'px'; p.style.lineHeight=lh; });
            }
            function nudgeScale(delta){
              dispScale = Math.max(0.5, Math.min(2.5, Math.round((dispScale + delta) * 100) / 100));
              try { localStorage.setItem('tp_display_font_scale_v1', String(dispScale)); } catch {}
              applyScaled();
            }
            function flip(){ document.body.style.transform = document.body.style.transform ? '' : 'scaleX(-1)'; }
            function invert(){
              if(!document.body.dataset.inv){ document.body.dataset.inv=1; document.body.style.background = '#f4f7fb'; document.body.style.color = '#0b0d10'; }
              else { delete document.body.dataset.inv; document.body.style.background = '#000'; document.body.style.color = '#e7ebf0'; }
            }
            const camVid  = document.getElementById('mirrorCamVideo');
            try { if (camVid) { camVid.playsInline = true; camVid.setAttribute('playsinline',''); camVid.setAttribute('webkit-playsinline',''); } } catch {}
            const camWrap = document.getElementById('mirrorCamWrap');
            const camPiP  = document.getElementById('camPiP');
            const camLoad = document.getElementById('mirrorCamLoading');
            // PiP toggle
            if (camPiP) {
              camPiP.onclick = async () => {
                try {
                  if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                  } else if (camVid && camVid.requestPictureInPicture) {
                    await camVid.requestPictureInPicture();
                  }
                } catch {}
              };
            }
            // Loading state until first frame
            let firstFrame = false;
            if (camVid) {
              camVid.addEventListener('loadeddata', () => {
                if (!firstFrame) { firstFrame = true; if (camWrap) camWrap.style.display='block'; if (camLoad) camLoad.style.display='none'; }
              });
              camVid.addEventListener('waiting', () => { if (firstFrame && camLoad) { camLoad.textContent='Reconnecting…'; camLoad.style.display='flex'; } });
              camVid.addEventListener('playing', () => { if (camLoad) camLoad.style.display='none'; });
              camVid.addEventListener('emptied', () => { firstFrame=false; if (camLoad){ camLoad.textContent='Connecting camera…'; camLoad.style.display='flex'; } if (camWrap) camWrap.style.display='none'; });
            }
            window.addEventListener('message', ev => {
              const d = ev.data||{};
              // WebRTC camera offer/candidate handling
              if (!window.__camPC && (d.type === 'cam-offer')) {
                try {
                  const pc = new RTCPeerConnection({ iceServers: [] });
                  window.__camPC = pc;
                  pc.ontrack = (e) => {
                    if (camVid && e.streams && e.streams[0]) { camVid.srcObject = e.streams[0]; try { camVid.play().catch(()=>{}); } catch{} }
                  };
                  pc.onicecandidate = (e) => { if (e.candidate) { try { window.opener && window.opener.postMessage({ type:'cam-ice', candidate:e.candidate }, '*'); } catch {} } };
                  pc.setRemoteDescription({ type:'offer', sdp: d.sdp }).then(async ()=>{
                    const ans = await pc.createAnswer();
                    await pc.setLocalDescription(ans);
                    window.opener && window.opener.postMessage({ type:'cam-answer', sdp: ans.sdp }, '*');
                  });
                } catch (err) { console.warn('Display cam-offer handling failed', err); }
                return; // stop further processing of this message
              } else if (window.__camPC && d.type === 'cam-ice' && d.candidate) {
                try { window.__camPC.addIceCandidate(d.candidate); } catch {}
                return;
              }
              if(d.type==='render'){ scriptEl.innerHTML = d.html||''; if(d.fontSize&&d.lineHeight) applyBase(d.fontSize,d.lineHeight); else applyScaled(); try{ updateEndSpacer(); }catch{} }
              if(d.type==='typography'){ if(d.fontSize&&d.lineHeight) applyBase(d.fontSize,d.lineHeight); try{ updateEndSpacer(); }catch{} }
              if(d.type==='scroll'){
                if (typeof d.ratio === 'number' && isFinite(d.ratio)){
                  const max = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
                  wrap.scrollTop = Math.round(d.ratio * max);
                } else {
                  wrap.scrollTop = d.top||0;
                }
              }
              // DISPLAY: report marker/active measurement back to opener/parent
              if (d.type === 'measure-request'){
                try {
                  const scroller = getScroller(document, window);
                  const marker = document.getElementById('marker-line');
                  const active = scriptEl.querySelector('p.active');
                  const markerY = marker ? relTop(marker, scroller, window) : null;
                  const activeY = active ? relTop(active, scroller, window) : null;
                  try { console.info('MEASURE FROM', location.pathname, 'scH=', (scroller===window? window.innerHeight : scroller.clientHeight), 'markerY=', markerY, 'activeY=', activeY); } catch {}
                  const tgt = (window.opener || window.parent);
                  if (tgt && typeof tgt.postMessage === 'function') tgt.postMessage({ type:'MEASURE', markerY, activeY }, '*');
                } catch {}
              }
              // DISPLAY: apply a scroll based on HUD-provided viewport Ys (in DISPLAY coords)
              if (d.type === 'display-apply' && typeof d.markerY === 'number' && typeof d.activeY === 'number'){
                try {
                  const scroller = getScroller(document, window);
                  const current = getScrollTop(scroller, window);
                  const delta = (d.activeY - d.markerY);
                  const maxTop = maxScrollTop(scroller, window, document);
                  const next = Math.max(0, Math.min(current + delta, maxTop));
                  setScrollTop(scroller, window, next);
                } catch {}
              }
              // Optional: mainstream-align by marker delta within the display window
              if (d.type === 'align-by-marker'){
                try {
                  const scroller = getScroller(document, window);
                  const marker = document.getElementById('marker-line');
                  const active = scriptEl.querySelector('p.active');
                  if (!marker || !active) return;
                  const mTop = relTop(marker, scroller, window);
                  const aTop = relTop(active, scroller, window);
                  const delta = aTop - mTop;
                  const current = getScrollTop(scroller, window);
                  const maxTop = maxScrollTop(scroller, window, document);
                  const next = Math.max(0, Math.min(current + delta, maxTop));
                  setScrollTop(scroller, window, next);
                } catch {}
              }
              // Align the end (last paragraph bottom) to the marker within display context
              if (d.type === 'END_TO_MARKER'){
                try {
                  const scroller = getScroller(document, window);
                  const marker = document.getElementById('marker-line');
                  // Optional virtualization hook: allow app to materialize last node when near end
                  try { if (typeof window.__ensureLastNode === 'function') window.__ensureLastNode(); } catch {}
                  const last = (document.querySelector('.transcript-line:last-of-type') || scriptEl.querySelector('p:last-of-type'));
                  if (!scroller || !marker || !last) return;
                  // Ensure end spacer is at least markerY + small pad
                  try { const mY = relTop(marker, scroller, window); ensureEndSpacer(document, scroller, window, mY); } catch {}
                  const markerY = relTop(marker, scroller, window);
                  let lastBottom = null;
                  if (last) lastBottom = relBottom(last, scroller, window);
                  else {
                    const totalH = (scroller===window ? (document.scrollingElement?.scrollHeight||0) : (scroller.scrollHeight||0));
                    lastBottom = Math.max(0, totalH - getScrollTop(scroller, window));
                  }
                  const delta = lastBottom - markerY;
                  if (Math.abs(delta) <= 1) return;
                  const current = getScrollTop(scroller, window);
                  const maxTop = maxScrollTop(scroller, window, document);
                  const next = Math.max(0, Math.min(current + delta, maxTop));
                  setScrollTop(scroller, window, next);
                  // tidy nudge if layout settles
                  requestAnimationFrame(()=>{
                    try {
                      let nb = null;
                      if (last) nb = relBottom(last, scroller, window);
                      else {
                        const totalH = (scroller===window ? (document.scrollingElement?.scrollHeight||0) : (scroller.scrollHeight||0));
                        nb = Math.max(0, totalH - getScrollTop(scroller, window));
                      }
                      const miss = nb - markerY;
                      if (Math.abs(miss) > 3){
                        const cur = getScrollTop(scroller, window);
                        const n2 = Math.max(0, Math.min(cur + miss, maxScrollTop(scroller, window, document)));
                        setScrollTop(scroller, window, n2);
                      }
                    } catch {}
                  });
                } catch {}
              }
              if(d.type==='preroll'){
                if(d.show){ preRoll.style.display='flex'; if(typeof d.n==='number') preRollNum.textContent=String(d.n); }
                else{ preRoll.style.display='none'; }
              }
              if(d.type==='toggle-ck'){
                document.body.classList.toggle('ck', !!d.on);
              }
            });
            document.getElementById('flip').onclick = flip;
            document.getElementById('invert').onclick = invert;
            try { window.addEventListener('resize', ()=>{ try{ updateEndSpacer(); }catch{} }, { passive:true }); } catch {}
            const camPiPBtn = document.getElementById('camPiP');
            if (camPiPBtn){
              camPiPBtn.onclick = async () => {
                try {
                  const v = document.getElementById('mirrorCam');
                  if (!v) { showCamLoading('No camera'); return; }
                  if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                  } else if (v.requestPictureInPicture) {
                    await v.requestPictureInPicture();
                  }
                } catch (e){ console.warn('PiP failed', e); }
              };
            }
            window.addEventListener('keydown', (e)=>{
              const k = (e.key||'').toLowerCase();
              if (k === 'f'){ e.preventDefault(); flip(); }
              if (k === 'i'){ e.preventDefault(); invert(); }
              // In-app zoom for display only (Ctrl/Cmd + +/-/0)
              if (e.ctrlKey || e.metaKey){
                if (k === '+' || k === '='){ e.preventDefault(); nudgeScale(+0.05); }
                else if (k === '-' || k === '_'){ e.preventDefault(); nudgeScale(-0.05); }
                else if (k === '0'){ e.preventDefault(); dispScale = 1.0; try{ localStorage.setItem('tp_display_font_scale_v1','1'); }catch{} applyScaled(); }
              }
            });
          </script>
        </body></html>