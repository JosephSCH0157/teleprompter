{
  "version": 3,
  "sources": ["../src/speech/asrSync.ts", "../src/speech/matcher.ts", "../src/speech/recognizer.ts", "../src/speech/orchestrator.ts"],
  "sourcesContent": ["const MAX_ERR_ABS = 2400;\nlet cachedPxPerLine = 0;\nlet cachedAt = 0;\nconst CACHE_TTL_MS = 5_000;\n\nfunction clamp(value: number, min: number, max: number): number {\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n}\n\nfunction measurePxPerLine(): number {\n  if (typeof window === 'undefined') return 56 * 1.4;\n  try {\n    const doc = document.documentElement;\n    const cs = getComputedStyle(doc);\n    const fs = parseFloat(cs.getPropertyValue('--tp-font-size')) || 56;\n    const lh = parseFloat(cs.getPropertyValue('--tp-line-height')) || 1.4;\n    return fs * lh;\n  } catch {\n    return 56 * 1.4;\n  }\n}\n\nfunction pxPerLine(): number {\n  const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\n  if (!cachedPxPerLine || (now - cachedAt) > CACHE_TTL_MS) {\n    cachedPxPerLine = measurePxPerLine();\n    cachedAt = now;\n  }\n  return cachedPxPerLine;\n}\n\nexport function emitAsrSync(errPx: number, confidence?: number): void {\n  if (typeof window === 'undefined') return;\n  const value = Number(errPx);\n  if (!Number.isFinite(value) || value === 0) return;\n  const detail = {\n    errPx: clamp(value, -MAX_ERR_ABS, MAX_ERR_ABS),\n    conf: clamp(Number.isFinite(confidence ?? 1) ? Number(confidence) : 1, 0, 1),\n  };\n  try {\n    window.dispatchEvent(new CustomEvent('tp:asr:sync', { detail }));\n  } catch {\n    // swallow dispatch errors\n  }\n}\n\nexport function emitAsrSyncFromLineDelta(deltaLines: number, confidence?: number): void {\n  const px = Number(deltaLines) * pxPerLine();\n  if (!Number.isFinite(px)) return;\n  emitAsrSync(px, confidence);\n}\n", "// Matcher: alignment, scoring and commit logic for speech-sync\r\n// This module is a conservative port/encapsulation of the inline matcher logic\r\n// found in the legacy runtime. It focuses on pure computational logic and\r\n// exposes a small procedural API the runtime can call from event handlers.\r\n\r\nexport type MatchConfig = {\r\n  MATCH_WINDOW_AHEAD: number;\r\n  MATCH_WINDOW_BACK: number;\r\n  SIM_THRESHOLD: number;\r\n  MAX_JUMP_AHEAD_WORDS: number;\r\n};\r\n\r\nexport type MatchResult = {\r\n  bestIdx: number;\r\n  bestSim: number;\r\n  topScores: Array<{ idx: number; score: number }>;\r\n};\r\n\r\n// Minimal similarity helpers (kept pure for unit testing)\r\nexport function normTokens(s: string): string[] {\r\n  // Align with sanitizeForMatch semantics: strip bracketed cues and normalize punctuation.\r\n  return String(s || '')\r\n    .toLowerCase()\r\n    .replace(/\\[[^\\]]+]/g, '')      // strip [pause]/[beat]/[note]\r\n    .replace(/[\u201C\u201D\"']/g, '')          // remove quotes\r\n    .replace(/[\u2014\u2013]/g, '-')            // normalize dashes\r\n    .replace(/[^\\w\\s-]/g, ' ')      // drop other punctuation\r\n    .replace(/\\s+/g, ' ')\r\n    .trim()\r\n    .split(' ')\r\n    .filter(Boolean);\r\n}\r\n\r\nexport function getNgrams(tokens: string[], n: number) {\r\n  const out: string[] = [];\r\n  for (let i = 0; i <= tokens.length - n; i++) out.push(tokens.slice(i, i + n).join(' '));\r\n  return out;\r\n}\r\n\r\nexport function cosineSimilarity(vec1: number[], vec2: number[]) {\r\n  let dot = 0,\r\n    n1 = 0,\r\n    n2 = 0;\r\n  for (let i = 0; i < vec1.length; i++) {\r\n    dot += vec1[i] * vec2[i];\r\n    n1 += vec1[i] * vec1[i];\r\n    n2 += vec2[i] * vec2[i];\r\n  }\r\n  return n1 && n2 ? dot / (Math.sqrt(n1) * Math.sqrt(n2)) : 0;\r\n}\r\n\r\n// Simplified TF-IDF-ish similarity using ngram counts (cheap, deterministic)\r\nexport function computeTFIDFSimilarity(tokens1: string[], tokens2: string[]) {\r\n  const ngrams1 = getNgrams(tokens1, 2).concat(getNgrams(tokens1, 3));\r\n  const ngrams2 = getNgrams(tokens2, 2).concat(getNgrams(tokens2, 3));\r\n  const all = Array.from(new Set([...ngrams1, ...ngrams2]));\r\n  const v1 = all.map((ng) => ngrams1.filter((x) => x === ng).length);\r\n  const v2 = all.map((ng) => ngrams2.filter((x) => x === ng).length);\r\n  return cosineSimilarity(v1, v2);\r\n}\r\n\r\nexport function computeJaccardSimilarity(tokens1: string[], tokens2: string[]) {\r\n  const s1 = new Set(tokens1.map((t) => t.toLowerCase()));\r\n  const s2 = new Set(tokens2.map((t) => t.toLowerCase()));\r\n  const inter = new Set([...s1].filter((x) => s2.has(x)));\r\n  const union = new Set([...s1, ...s2]);\r\n  return union.size ? inter.size / union.size : 0;\r\n}\r\n\r\nexport function computeLineSimilarity(spokenTokens: string[], scriptText: string) {\r\n  const scriptTokens = normTokens(scriptText);\r\n  const tfidf = computeTFIDFSimilarity(spokenTokens, scriptTokens);\r\n  const jacc = computeJaccardSimilarity(spokenTokens, scriptTokens);\r\n  // Simple char overlap as fallback\r\n  const charsA = spokenTokens.join(' ');\r\n  const charsB = scriptTokens.join(' ');\r\n  const charF1 = (() => {\r\n    const setA = new Set(charsA.split(''));\r\n    const setB = new Set(charsB.split(''));\r\n    const inter = new Set([...setA].filter((x) => setB.has(x)));\r\n    const p = setA.size ? inter.size / setA.size : 0;\r\n    const r = setB.size ? inter.size / setB.size : 0;\r\n    return p + r > 0 ? (2 * p * r) / (p + r) : 0;\r\n  })();\r\n\r\n  let score = 0.5 * tfidf + 0.3 * charF1 + 0.2 * jacc;\r\n  if (scriptTokens.length < 5) score -= 0.12;\r\n  return Math.max(0, Math.min(1, score));\r\n}\r\n\r\n// Top-level matching API. It expects precomputed scriptWords and paraIndex\r\n// from the runtime and returns the best match for the spoken token batch.\r\nexport function matchBatch(\r\n  spokenTokens: string[],\r\n  scriptWords: string[],\r\n  paraIndex: Array<{ start: number; end: number; key: string; isMeta?: boolean; isNonSpoken?: boolean }>,\r\n  vParaIndex: string[] | null,\r\n  cfg: MatchConfig,\r\n  currentIndex: number,\r\n  _viterbiState?: { path: number[]; pred?: number }\r\n): MatchResult {\r\n  const batch = spokenTokens.slice(-Math.max(3, spokenTokens.length));\r\n  const candidates = new Set<number>();\r\n  const windowAhead = cfg.MATCH_WINDOW_AHEAD;\r\n\r\n  const candidateStart = Math.max(0, Math.floor(currentIndex) - cfg.MATCH_WINDOW_BACK);\r\n  const candidateEnd = Math.min(scriptWords.length - 1, Math.floor(currentIndex) + windowAhead);\r\n  for (let i = candidateStart; i <= candidateEnd; i++) candidates.add(i);\r\n\r\n  const scores: Record<number, number> = {};\r\n  const candidateArray = Array.from(candidates);\r\n  for (const j of candidateArray) {\r\n    const para = vParaIndex ? vParaIndex[j] : paraIndex[j]?.key;\r\n    if (!para) continue;\r\n    let sc = computeLineSimilarity(batch, String(para));\r\n    if (paraIndex[j]?.isMeta) sc = sc * 0.5 - 0.2;\r\n    else if (paraIndex[j]?.isNonSpoken) sc = sc - 0.6;\r\n    scores[j] = sc;\r\n  }\r\n\r\n  const top = Object.entries(scores)\r\n    .sort(([, a], [, b]) => (b as number) - (a as number))\r\n    .slice(0, 3)\r\n    .map(([idx, score]) => ({ idx: Number(idx), score: Number((score as number).toFixed(3)) }));\r\n\r\n  // Windowed matching band around the currently visible/expected line.\r\n  // Unless the top candidate is very strong (>= 0.82), prefer a candidate within \u00B140.\r\n  const radius = 40;\r\n  const bandStart = Math.max(0, Math.floor(currentIndex) - radius);\r\n  const bandEnd = Math.min((vParaIndex ? vParaIndex.length : paraIndex.length) - 1, Math.floor(currentIndex) + radius);\r\n  let best = top[0] || { idx: Math.max(0, currentIndex), score: 0 };\r\n  if (best && (best.idx < bandStart || best.idx > bandEnd) && (best.score as number) < 0.82) {\r\n    const inBand = top.find(t => t.idx >= bandStart && t.idx <= bandEnd);\r\n    if (inBand) best = inBand;\r\n  }\r\n  return { bestIdx: best.idx, bestSim: best.score as number, topScores: top };\r\n}\r\n", "// Lightweight wrapper around the Web Speech API for the teleprompter\r\n// Exposes a simple Recognizer class that emits transcripts to a callback.\r\nexport type RecognizerOptions = {\r\n  lang?: string;\r\n  interimIntervalMs?: number; // how often to forward interim results (debounce)\r\n  maxAlternatives?: number;\r\n};\r\n\r\ntype ResultCallback = (_transcript: string, _isFinal: boolean) => void;\r\n\r\nexport class Recognizer {\r\n  private recog: any | null = null;\r\n  private cb: ResultCallback | null = null;\r\n  private opts: RecognizerOptions;\r\n  private _lastInterimAt = 0;\r\n  private shouldRun = false;\r\n  private restartTimer: ReturnType<typeof setTimeout> | null = null;\r\n\r\n  constructor(opts: RecognizerOptions = {}) {\r\n    this.opts = Object.assign({ lang: 'en-US', interimIntervalMs: 150, maxAlternatives: 2 }, opts);\r\n  }\r\n\r\n  private logSpeechError(ev: any) {\r\n    try {\r\n      console.log('[speech] error', ev);\r\n    } catch {}\r\n  }\r\n\r\n  private clearRestartTimer() {\r\n    if (this.restartTimer !== null) {\r\n      clearTimeout(this.restartTimer);\r\n      this.restartTimer = null;\r\n    }\r\n  }\r\n\r\n  private scheduleRestart(delayMs: number, opts: { stopFirst?: boolean } = {}) {\r\n    if (!this.shouldRun) return;\r\n    if (!this.recog || typeof this.recog.start !== 'function') return;\r\n    const recognition = this.recog;\r\n    this.restartTimer = setTimeout(() => {\r\n      this.restartTimer = null;\r\n      if (!this.shouldRun) return;\r\n      if (opts.stopFirst) {\r\n        try { recognition.stop?.(); } catch {}\r\n      }\r\n      try {\r\n        recognition.start?.();\r\n      } catch (err) {\r\n        try { console.warn('[speech] restart failed', err); } catch {}\r\n      }\r\n    }, delayMs);\r\n  }\r\n\r\n  available(): boolean {\r\n    return Boolean((globalThis as any).SpeechRecognition || (globalThis as any).webkitSpeechRecognition);\r\n  }\r\n\r\n  start(cb: ResultCallback) {\r\n    this.cb = cb;\r\n    const SR = (globalThis as any).SpeechRecognition || (globalThis as any).webkitSpeechRecognition;\r\n    if (!SR) throw new Error('SpeechRecognition not available');\r\n    try {\r\n      this.recog = new SR();\r\n      try {\r\n        if (typeof window !== 'undefined') {\r\n          (window as any).recog = this.recog;\r\n        }\r\n      } catch {}\r\n      this.shouldRun = true;\r\n      this.clearRestartTimer();\r\n      this.recog.continuous = true;\r\n      this.recog.interimResults = true;\r\n      this.recog.lang = this.opts.lang;\r\n      try {\r\n        this.recog.maxAlternatives = Math.max(2, this.recog.maxAlternatives || 0, this.opts.maxAlternatives || 2);\r\n      } catch {}\r\n\r\n      this.recog.onstart = () => {};\r\n      this.recog.onerror = (ev: any) => {\r\n        this.logSpeechError(ev);\r\n        if (!ev || ev.error !== 'network') return;\r\n        if (!this.shouldRun) return;\r\n        this.clearRestartTimer();\r\n        this.scheduleRestart(800, { stopFirst: true });\r\n      };\r\n      this.recog.onend = () => {\r\n        if (!this.shouldRun) return;\r\n        if (this.restartTimer !== null) return;\r\n        this.scheduleRestart(500);\r\n      };\r\n\r\n      this.recog.onresult = (e: any) => {\r\n        let interim = '';\r\n        let finals = '';\r\n        for (let i = e.resultIndex; i < e.results.length; i++) {\r\n          const r = e.results[i];\r\n          if (r.isFinal) finals += (r[0]?.transcript || '') + ' ';\r\n          else interim += (r[0]?.transcript || '') + ' ';\r\n        }\r\n        if (finals && this.cb) this.cb(finals.trim(), true);\r\n        const now = performance.now();\r\n        if (interim && now - this._lastInterimAt > (this.opts.interimIntervalMs || 150)) {\r\n          this._lastInterimAt = now;\r\n          if (this.cb) this.cb(interim.trim(), false);\r\n        }\r\n      };\r\n\r\n      try {\r\n        this.recog.start();\r\n      } catch (e) {\r\n        // Chrome may throw if start is requested too soon; rely on onerror/onend.\r\n        this.logSpeechError(e);\r\n      }\r\n    } catch (err) {\r\n      this.shouldRun = false;\r\n      this.clearRestartTimer();\r\n      this.recog = null;\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    try {\r\n      this.shouldRun = false;\r\n      this.clearRestartTimer();\r\n      if (this.recog) {\r\n        try { this.recog.stop(); } catch {}\r\n      }\r\n    } finally {\r\n      this.recog = null;\r\n      this.cb = null;\r\n    }\r\n  }\r\n}\r\n\r\n// Export a convenience factory used by a loader or runtime shim\r\nexport function createRecognizer(opts?: RecognizerOptions) {\r\n  return new Recognizer(opts);\r\n}\r\n", "import { emitAsrSyncFromLineDelta } from './asrSync';\r\nimport * as matcher from './matcher';\r\nimport type { Recognizer } from './recognizer';\r\nimport { createRecognizer } from './recognizer';\r\n\r\nconst SILENCE_HOLD_MS = 1200;\r\n\r\nlet lastAsrWordTs = 0;\r\nlet silenceTimer: ReturnType<typeof setTimeout> | null = null;\r\nlet silenceActive = true;\r\n\r\nfunction nowMs(): number {\r\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\r\n    return performance.now();\r\n  }\r\n  return Date.now();\r\n}\r\n\r\nfunction dispatchAsrSilence(silent: boolean, ts: number): void {\r\n  if (typeof window === 'undefined') return;\r\n  try {\r\n    window.dispatchEvent(new CustomEvent('tp:asr:silence', { detail: { silent, ts } }));\r\n  } catch {\r\n    // swallow dispatch errors\r\n  }\r\n}\r\n\r\nfunction emitSpeechState(running: boolean): void {\r\n  if (typeof window === 'undefined') return;\r\n  try {\r\n    window.dispatchEvent(new CustomEvent('tp:speech-state', { detail: { running } }));\r\n  } catch {\r\n    // non-fatal in case window is weird\r\n  }\r\n}\r\n\r\nfunction setSilenceState(nextSilent: boolean, ts: number): void {\r\n  if (silenceActive === nextSilent) return;\r\n  silenceActive = nextSilent;\r\n  dispatchAsrSilence(silenceActive, ts);\r\n}\r\n\r\nfunction scheduleSilenceCheck(): void {\r\n  if (silenceTimer) {\r\n    clearTimeout(silenceTimer);\r\n    silenceTimer = null;\r\n  }\r\n  silenceTimer = setTimeout(() => {\r\n    silenceTimer = null;\r\n    const now = nowMs();\r\n    if (!silenceActive && now - lastAsrWordTs >= SILENCE_HOLD_MS) {\r\n      setSilenceState(true, now);\r\n    }\r\n  }, SILENCE_HOLD_MS);\r\n}\r\n\r\nfunction noteAsrSpeechActivity(text: string): void {\r\n  if (!text || !text.trim()) return;\r\n  const now = nowMs();\r\n  lastAsrWordTs = now;\r\n  if (silenceActive) {\r\n    setSilenceState(false, now);\r\n  }\r\n  scheduleSilenceCheck();\r\n}\r\n\r\nif (typeof window !== 'undefined') {\r\n  dispatchAsrSilence(true, nowMs());\r\n}\r\n\r\nexport interface MatchEvent {\r\n  idx: number;\r\n  sim: number;\r\n  isFinal: boolean;\r\n}\r\n\r\nlet _rec: Recognizer | null = null;\r\nlet _cb: ((_evt: MatchEvent) => void) | null = null;\r\n\r\n// Lightweight cosine similarity for HUD transcript enrichment (dev only usage)\r\nfunction simCosine(a: string, b: string): number {\r\n  try {\r\n    const tok = (s: string) => s.toLowerCase().replace(/[^\\p{L}\\p{N}\\s]+/gu, ' ').split(/\\s+/).filter(Boolean);\r\n    const A = tok(a), B = tok(b);\r\n    if (!A.length || !B.length) return 0;\r\n    const tf = (arr: string[]) => arr.reduce((m, w) => (m.set(w, (m.get(w) || 0) + 1), m), new Map<string, number>());\r\n    const TA = tf(A), TB = tf(B);\r\n    let dot = 0; let na = 0; let nb = 0;\r\n    for (const [w, v] of TA) { na += v*v; if (TB.has(w)) dot += v * (TB.get(w) || 0); }\r\n    for (const v of TB.values()) nb += v*v;\r\n    const denom = Math.sqrt(na) * Math.sqrt(nb);\r\n    return denom ? dot / denom : 0;\r\n  } catch { return 0; }\r\n}\r\n\r\nfunction getExpectedLineText(): string | undefined {\r\n  try { return (window as any).__tpScript?.currentExpectedText?.(); } catch { return undefined; }\r\n}\r\n\r\nfunction dispatchTranscript(text: string, final: boolean) {\r\n  try {\r\n    const expected = getExpectedLineText();\r\n    const sim = expected ? simCosine(text, expected) : undefined;\r\n    const detail = {\r\n      text,\r\n      final,\r\n      timestamp: Date.now(),\r\n      sim,\r\n      source: 'orchestrator' as const,\r\n    };\r\n    try { console.log('[ASR] dispatchTranscript', detail); } catch {}\r\n    window.dispatchEvent(new CustomEvent('tp:speech:transcript', { detail }));\r\n  } catch {}\r\n}\r\n\r\nfunction _getRuntimeScriptState() {\r\n  // runtime stores these globals (legacy). Use safe access and sensible defaults.\r\n  const w: any = window as any;\r\n  const scriptWords: string[] = Array.isArray(w.scriptWords) ? w.scriptWords : [];\r\n  const paraIndex: any[] = Array.isArray(w.paraIndex) ? w.paraIndex : [];\r\n  const vParaIndex = Array.isArray(w.__vParaIndex) ? w.__vParaIndex : null;\r\n  const cfg = {\r\n    MATCH_WINDOW_AHEAD: typeof w.MATCH_WINDOW_AHEAD === 'number' ? w.MATCH_WINDOW_AHEAD : 240,\r\n    MATCH_WINDOW_BACK: typeof w.MATCH_WINDOW_BACK === 'number' ? w.MATCH_WINDOW_BACK : 40,\r\n    SIM_THRESHOLD: typeof w.SIM_THRESHOLD === 'number' ? w.SIM_THRESHOLD : 0.46,\r\n    MAX_JUMP_AHEAD_WORDS: typeof w.MAX_JUMP_AHEAD_WORDS === 'number' ? w.MAX_JUMP_AHEAD_WORDS : 18,\r\n  } as matcher.MatchConfig;\r\n  const currentIndex = typeof (w.currentIndex) === 'number' ? w.currentIndex : 0;\r\n  const viterbiState = w.__viterbiIPred || null;\r\n  return { scriptWords, paraIndex, vParaIndex, cfg, currentIndex, viterbiState };\r\n}\r\n\r\nexport function matchBatch(text: string, isFinal: boolean): matcher.MatchResult {\r\n  try {\r\n    try {\r\n      console.log('[ASR] matchBatch', {\r\n        text,\r\n        isFinal,\r\n        len: typeof text === 'string' ? text.length : 0,\r\n      });\r\n    } catch {}\r\n    const spokenTokens = matcher.normTokens(text || '');\r\n    if (spokenTokens.length) {\r\n      noteAsrSpeechActivity(text);\r\n    }\r\n    const { scriptWords, paraIndex, vParaIndex, cfg, currentIndex, viterbiState } = _getRuntimeScriptState();\r\n    const res = matcher.matchBatch(spokenTokens, scriptWords, paraIndex, vParaIndex, cfg, currentIndex, viterbiState as any);\r\n\r\n    // Convert line delta to px error so the adaptive governor can respond\r\n    try {\r\n      const deltaLines = Number(res.bestIdx) - Number(currentIndex || 0);\r\n      if (deltaLines) {\r\n        const conf = Math.max(0, Math.min(1, res.bestSim || 0)) * (isFinal ? 1 : 0.6);\r\n        emitAsrSyncFromLineDelta(deltaLines, conf);\r\n      }\r\n    } catch {\r\n      // non-fatal; continue flow\r\n    }\r\n\r\n    // notify consumer callback if present\r\n    if (_cb) {\r\n      try {\r\n        _cb({ idx: res.bestIdx, sim: res.bestSim, isFinal });\r\n      } catch (e) {\r\n        try { console.warn('[TP] speech callback failed', e); } catch {}\r\n      }\r\n    }\r\n    return res;\r\n  } catch (err) {\r\n    try { console.warn('[TP] matchBatch error', err); } catch {}\r\n    // return a safe default\r\n    return { bestIdx: 0, bestSim: 0, topScores: [] };\r\n  }\r\n}\r\n\r\nexport function startRecognizer(cb: (_evt: MatchEvent) => void, opts?: { lang?: string }) {\r\n  try { console.log('[ASR] startRecognizer invoked with opts:', opts); } catch {}\r\n  if (_rec) {\r\n    // already running; replace callback\r\n    _cb = cb;\r\n    return;\r\n  }\r\n  try {\r\n    _rec = createRecognizer(opts as any);\r\n    try {\r\n      console.log('[ASR] createRecognizer returned:', _rec ? 'ok' : 'null');\r\n    } catch {}\r\n    _cb = cb;\r\n    if (!_rec) {\r\n      try { console.warn('[ASR] startRecognizer: recognizer is null; createRecognizer probably failed'); } catch {}\r\n      return;\r\n    }\r\n    try {\r\n      console.log('[ASR] calling recognizer.start()');\r\n      _rec.start((transcript: string, isFinal: boolean) => {\r\n        try { console.log('[ASR] raw recognizer result', { transcript, isFinal }); } catch {}\r\n        const text = transcript || '';\r\n        matchBatch(text, isFinal);\r\n        dispatchTranscript(text, isFinal);\r\n      });\r\n      try { console.log('[ASR] recognizer.start() returned without throwing'); } catch {}\r\n    } catch (err) {\r\n      try { console.error('[ASR] recognizer.start() threw', err); } catch {}\r\n      throw err;\r\n    }\r\n    emitSpeechState(true);\r\n  } catch (err) {\r\n    try { console.error('[ASR] createRecognizer/startRecognizer failed', err); } catch {}\r\n    _rec = null;\r\n    _cb = null;\r\n    throw err;\r\n  }\r\n}\r\n\r\nexport function stopRecognizer() {\r\n  try {\r\n    if (_rec) {\r\n      try { _rec.stop(); } catch {}\r\n      _rec = null;\r\n      emitSpeechState(false);\r\n    }\r\n  } finally {\r\n    _cb = null;\r\n  }\r\n}\r\n\r\n// Attach a safe shim on window for legacy callers. Loader will import this file\r\n// and wire the functions onto window.__tpSpeech.\r\n(function attachShim() {\r\n  try {\r\n    const w: any = window as any;\r\n    try { console.log('[ASR] orchestrator global shim installing'); } catch {}\r\n    w.__tpSpeech = w.__tpSpeech || {};\r\n    w.__tpSpeech.startRecognizer = startRecognizer;\r\n    w.__tpSpeech.stopRecognizer = stopRecognizer;\r\n    w.__tpSpeech.matchBatch = matchBatch;\r\n  } catch {\r\n    // noop\r\n  }\r\n})();\r\n"],
  "mappings": "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",
  "names": ["matchBatch"]
}
