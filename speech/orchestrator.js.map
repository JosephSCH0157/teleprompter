{
  "version": 3,
  "sources": ["../src/speech/matcher.ts", "../src/speech/recognizer.ts", "../src/speech/orchestrator.ts"],
  "sourcesContent": ["// Matcher: alignment, scoring and commit logic for speech-sync\r\n// This module is a conservative port/encapsulation of the inline matcher logic\r\n// found in the legacy runtime. It focuses on pure computational logic and\r\n// exposes a small procedural API the runtime can call from event handlers.\r\n\r\nexport type MatchConfig = {\r\n  MATCH_WINDOW_AHEAD: number;\r\n  MATCH_WINDOW_BACK: number;\r\n  SIM_THRESHOLD: number;\r\n  MAX_JUMP_AHEAD_WORDS: number;\r\n};\r\n\r\nexport type MatchResult = {\r\n  bestIdx: number;\r\n  bestSim: number;\r\n  topScores: Array<{ idx: number; score: number }>;\r\n};\r\n\r\n// Minimal similarity helpers (kept pure for unit testing)\r\nexport function normTokens(s: string): string[] {\r\n  // Align with sanitizeForMatch semantics: strip bracketed cues and normalize punctuation.\r\n  return String(s || '')\r\n    .toLowerCase()\r\n    .replace(/\\[[^\\]]+]/g, '')      // strip [pause]/[beat]/[note]\r\n    .replace(/[\u201C\u201D\"']/g, '')          // remove quotes\r\n    .replace(/[\u2014\u2013]/g, '-')            // normalize dashes\r\n    .replace(/[^\\w\\s-]/g, ' ')      // drop other punctuation\r\n    .replace(/\\s+/g, ' ')\r\n    .trim()\r\n    .split(' ')\r\n    .filter(Boolean);\r\n}\r\n\r\nexport function getNgrams(tokens: string[], n: number) {\r\n  const out: string[] = [];\r\n  for (let i = 0; i <= tokens.length - n; i++) out.push(tokens.slice(i, i + n).join(' '));\r\n  return out;\r\n}\r\n\r\nexport function cosineSimilarity(vec1: number[], vec2: number[]) {\r\n  let dot = 0,\r\n    n1 = 0,\r\n    n2 = 0;\r\n  for (let i = 0; i < vec1.length; i++) {\r\n    dot += vec1[i] * vec2[i];\r\n    n1 += vec1[i] * vec1[i];\r\n    n2 += vec2[i] * vec2[i];\r\n  }\r\n  return n1 && n2 ? dot / (Math.sqrt(n1) * Math.sqrt(n2)) : 0;\r\n}\r\n\r\n// Simplified TF-IDF-ish similarity using ngram counts (cheap, deterministic)\r\nexport function computeTFIDFSimilarity(tokens1: string[], tokens2: string[]) {\r\n  const ngrams1 = getNgrams(tokens1, 2).concat(getNgrams(tokens1, 3));\r\n  const ngrams2 = getNgrams(tokens2, 2).concat(getNgrams(tokens2, 3));\r\n  const all = Array.from(new Set([...ngrams1, ...ngrams2]));\r\n  const v1 = all.map((ng) => ngrams1.filter((x) => x === ng).length);\r\n  const v2 = all.map((ng) => ngrams2.filter((x) => x === ng).length);\r\n  return cosineSimilarity(v1, v2);\r\n}\r\n\r\nexport function computeJaccardSimilarity(tokens1: string[], tokens2: string[]) {\r\n  const s1 = new Set(tokens1.map((t) => t.toLowerCase()));\r\n  const s2 = new Set(tokens2.map((t) => t.toLowerCase()));\r\n  const inter = new Set([...s1].filter((x) => s2.has(x)));\r\n  const union = new Set([...s1, ...s2]);\r\n  return union.size ? inter.size / union.size : 0;\r\n}\r\n\r\nexport function computeLineSimilarity(spokenTokens: string[], scriptText: string) {\r\n  const scriptTokens = normTokens(scriptText);\r\n  const tfidf = computeTFIDFSimilarity(spokenTokens, scriptTokens);\r\n  const jacc = computeJaccardSimilarity(spokenTokens, scriptTokens);\r\n  // Simple char overlap as fallback\r\n  const charsA = spokenTokens.join(' ');\r\n  const charsB = scriptTokens.join(' ');\r\n  const charF1 = (() => {\r\n    const setA = new Set(charsA.split(''));\r\n    const setB = new Set(charsB.split(''));\r\n    const inter = new Set([...setA].filter((x) => setB.has(x)));\r\n    const p = setA.size ? inter.size / setA.size : 0;\r\n    const r = setB.size ? inter.size / setB.size : 0;\r\n    return p + r > 0 ? (2 * p * r) / (p + r) : 0;\r\n  })();\r\n\r\n  let score = 0.5 * tfidf + 0.3 * charF1 + 0.2 * jacc;\r\n  if (scriptTokens.length < 5) score -= 0.12;\r\n  return Math.max(0, Math.min(1, score));\r\n}\r\n\r\n// Top-level matching API. It expects precomputed scriptWords and paraIndex\r\n// from the runtime and returns the best match for the spoken token batch.\r\nexport function matchBatch(\r\n  spokenTokens: string[],\r\n  scriptWords: string[],\r\n  paraIndex: Array<{ start: number; end: number; key: string; isMeta?: boolean; isNonSpoken?: boolean }>,\r\n  vParaIndex: string[] | null,\r\n  cfg: MatchConfig,\r\n  currentIndex: number,\r\n  _viterbiState?: { path: number[]; pred?: number }\r\n): MatchResult {\r\n  const batch = spokenTokens.slice(-Math.max(3, spokenTokens.length));\r\n  const candidates = new Set<number>();\r\n  const windowAhead = cfg.MATCH_WINDOW_AHEAD;\r\n\r\n  const candidateStart = Math.max(0, Math.floor(currentIndex) - cfg.MATCH_WINDOW_BACK);\r\n  const candidateEnd = Math.min(scriptWords.length - 1, Math.floor(currentIndex) + windowAhead);\r\n  for (let i = candidateStart; i <= candidateEnd; i++) candidates.add(i);\r\n\r\n  const scores: Record<number, number> = {};\r\n  const candidateArray = Array.from(candidates);\r\n  for (const j of candidateArray) {\r\n    const para = vParaIndex ? vParaIndex[j] : paraIndex[j]?.key;\r\n    if (!para) continue;\r\n    let sc = computeLineSimilarity(batch, String(para));\r\n    if (paraIndex[j]?.isMeta) sc = sc * 0.5 - 0.2;\r\n    else if (paraIndex[j]?.isNonSpoken) sc = sc - 0.6;\r\n    scores[j] = sc;\r\n  }\r\n\r\n  const top = Object.entries(scores)\r\n    .sort(([, a], [, b]) => (b as number) - (a as number))\r\n    .slice(0, 3)\r\n    .map(([idx, score]) => ({ idx: Number(idx), score: Number((score as number).toFixed(3)) }));\r\n\r\n  // Windowed matching band around the currently visible/expected line.\r\n  // Unless the top candidate is very strong (>= 0.82), prefer a candidate within \u00B140.\r\n  const radius = 40;\r\n  const bandStart = Math.max(0, Math.floor(currentIndex) - radius);\r\n  const bandEnd = Math.min((vParaIndex ? vParaIndex.length : paraIndex.length) - 1, Math.floor(currentIndex) + radius);\r\n  let best = top[0] || { idx: Math.max(0, currentIndex), score: 0 };\r\n  if (best && (best.idx < bandStart || best.idx > bandEnd) && (best.score as number) < 0.82) {\r\n    const inBand = top.find(t => t.idx >= bandStart && t.idx <= bandEnd);\r\n    if (inBand) best = inBand;\r\n  }\r\n  return { bestIdx: best.idx, bestSim: best.score as number, topScores: top };\r\n}\r\n", "// Lightweight wrapper around the Web Speech API for the teleprompter\r\n// Exposes a simple Recognizer class that emits transcripts to a callback.\r\nexport type RecognizerOptions = {\r\n  lang?: string;\r\n  interimIntervalMs?: number; // how often to forward interim results (debounce)\r\n  maxAlternatives?: number;\r\n};\r\n\r\ntype ResultCallback = (_transcript: string, _isFinal: boolean) => void;\r\n\r\nexport class Recognizer {\r\n  private recog: any | null = null;\r\n  private cb: ResultCallback | null = null;\r\n  private opts: RecognizerOptions;\r\n  private _lastInterimAt = 0;\r\n\r\n  constructor(opts: RecognizerOptions = {}) {\r\n    this.opts = Object.assign({ lang: 'en-US', interimIntervalMs: 150, maxAlternatives: 2 }, opts);\r\n  }\r\n\r\n  available(): boolean {\r\n    return Boolean((globalThis as any).SpeechRecognition || (globalThis as any).webkitSpeechRecognition);\r\n  }\r\n\r\n  start(cb: ResultCallback) {\r\n    this.cb = cb;\r\n    const SR = (globalThis as any).SpeechRecognition || (globalThis as any).webkitSpeechRecognition;\r\n    if (!SR) throw new Error('SpeechRecognition not available');\r\n    try {\r\n      this.recog = new SR();\r\n      this.recog.continuous = true;\r\n      this.recog.interimResults = true;\r\n      this.recog.lang = this.opts.lang;\r\n      try {\r\n        this.recog.maxAlternatives = Math.max(2, this.recog.maxAlternatives || 0, this.opts.maxAlternatives || 2);\r\n      } catch {}\r\n\r\n      this.recog.onstart = () => {};\r\n      this.recog.onend = () => {};\r\n\r\n      this.recog.onresult = (e: any) => {\r\n        let interim = '';\r\n        let finals = '';\r\n        for (let i = e.resultIndex; i < e.results.length; i++) {\r\n          const r = e.results[i];\r\n          if (r.isFinal) finals += (r[0]?.transcript || '') + ' ';\r\n          else interim += (r[0]?.transcript || '') + ' ';\r\n        }\r\n        if (finals && this.cb) this.cb(finals.trim(), true);\r\n        const now = performance.now();\r\n        if (interim && now - this._lastInterimAt > (this.opts.interimIntervalMs || 150)) {\r\n          this._lastInterimAt = now;\r\n          if (this.cb) this.cb(interim.trim(), false);\r\n        }\r\n      };\r\n\r\n      try {\r\n        this.recog.start();\r\n      } catch (e) {\r\n        // start may throw depending on permissions/state\r\n        throw e;\r\n      }\r\n    } catch (err) {\r\n      this.recog = null;\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    try {\r\n      if (this.recog) {\r\n        try { this.recog.stop(); } catch {}\r\n      }\r\n    } finally {\r\n      this.recog = null;\r\n      this.cb = null;\r\n    }\r\n  }\r\n}\r\n\r\n// Export a convenience factory used by a loader or runtime shim\r\nexport function createRecognizer(opts?: RecognizerOptions) {\r\n  return new Recognizer(opts);\r\n}\r\n", "import * as matcher from './matcher';\r\nimport type { Recognizer } from './recognizer';\r\nimport { createRecognizer } from './recognizer';\r\n\r\nexport interface MatchEvent {\r\n  idx: number;\r\n  sim: number;\r\n  isFinal: boolean;\r\n}\r\n\r\nlet _rec: Recognizer | null = null;\r\nlet _cb: ((_evt: MatchEvent) => void) | null = null;\r\n\r\n// Lightweight cosine similarity for HUD transcript enrichment (dev only usage)\r\nfunction simCosine(a: string, b: string): number {\r\n  try {\r\n    const tok = (s: string) => s.toLowerCase().replace(/[^\\p{L}\\p{N}\\s]+/gu, ' ').split(/\\s+/).filter(Boolean);\r\n    const A = tok(a), B = tok(b);\r\n    if (!A.length || !B.length) return 0;\r\n    const tf = (arr: string[]) => arr.reduce((m, w) => (m.set(w, (m.get(w) || 0) + 1), m), new Map<string, number>());\r\n    const TA = tf(A), TB = tf(B);\r\n    let dot = 0; let na = 0; let nb = 0;\r\n    for (const [w, v] of TA) { na += v*v; if (TB.has(w)) dot += v * (TB.get(w) || 0); }\r\n    for (const v of TB.values()) nb += v*v;\r\n    const denom = Math.sqrt(na) * Math.sqrt(nb);\r\n    return denom ? dot / denom : 0;\r\n  } catch { return 0; }\r\n}\r\n\r\nfunction getExpectedLineText(): string | undefined {\r\n  try { return (window as any).__tpScript?.currentExpectedText?.(); } catch { return undefined; }\r\n}\r\n\r\nfunction dispatchTranscript(text: string, final: boolean) {\r\n  try {\r\n    const expected = getExpectedLineText();\r\n    const sim = expected ? simCosine(text, expected) : undefined;\r\n    const detail = { text, final, ts: Date.now(), sim };\r\n    window.dispatchEvent(new CustomEvent('tp:speech:transcript', { detail }));\r\n  } catch {}\r\n}\r\n\r\nfunction _getRuntimeScriptState() {\r\n  // runtime stores these globals (legacy). Use safe access and sensible defaults.\r\n  const w: any = window as any;\r\n  const scriptWords: string[] = Array.isArray(w.scriptWords) ? w.scriptWords : [];\r\n  const paraIndex: any[] = Array.isArray(w.paraIndex) ? w.paraIndex : [];\r\n  const vParaIndex = Array.isArray(w.__vParaIndex) ? w.__vParaIndex : null;\r\n  const cfg = {\r\n    MATCH_WINDOW_AHEAD: typeof w.MATCH_WINDOW_AHEAD === 'number' ? w.MATCH_WINDOW_AHEAD : 240,\r\n    MATCH_WINDOW_BACK: typeof w.MATCH_WINDOW_BACK === 'number' ? w.MATCH_WINDOW_BACK : 40,\r\n    SIM_THRESHOLD: typeof w.SIM_THRESHOLD === 'number' ? w.SIM_THRESHOLD : 0.46,\r\n    MAX_JUMP_AHEAD_WORDS: typeof w.MAX_JUMP_AHEAD_WORDS === 'number' ? w.MAX_JUMP_AHEAD_WORDS : 18,\r\n  } as matcher.MatchConfig;\r\n  const currentIndex = typeof (w.currentIndex) === 'number' ? w.currentIndex : 0;\r\n  const viterbiState = w.__viterbiIPred || null;\r\n  return { scriptWords, paraIndex, vParaIndex, cfg, currentIndex, viterbiState };\r\n}\r\n\r\nexport function matchBatch(text: string, isFinal: boolean): matcher.MatchResult {\r\n  try {\r\n    const spokenTokens = matcher.normTokens(text || '');\r\n    const { scriptWords, paraIndex, vParaIndex, cfg, currentIndex, viterbiState } = _getRuntimeScriptState();\r\n    const res = matcher.matchBatch(spokenTokens, scriptWords, paraIndex, vParaIndex, cfg, currentIndex, viterbiState as any);\r\n\r\n    // notify consumer callback if present\r\n    if (_cb) {\r\n      try {\r\n        _cb({ idx: res.bestIdx, sim: res.bestSim, isFinal });\r\n      } catch (e) {\r\n        try { console.warn('[TP] speech callback failed', e); } catch {}\r\n      }\r\n    }\r\n    return res;\r\n  } catch (err) {\r\n    try { console.warn('[TP] matchBatch error', err); } catch {}\r\n    // return a safe default\r\n    return { bestIdx: 0, bestSim: 0, topScores: [] };\r\n  }\r\n}\r\n\r\nexport function startRecognizer(cb: (_evt: MatchEvent) => void, opts?: { lang?: string }) {\r\n  if (_rec) {\r\n    // already running; replace callback\r\n    _cb = cb;\r\n    return;\r\n  }\r\n  try {\r\n    _rec = createRecognizer(opts as any);\r\n    _cb = cb;\r\n    _rec.start((transcript: string, isFinal: boolean) => {\r\n      const text = transcript || '';\r\n      matchBatch(text, isFinal);\r\n      dispatchTranscript(text, isFinal);\r\n    });\r\n  } catch (err) {\r\n    try { console.warn('[TP] startRecognizer failed', err); } catch {}\r\n    _rec = null;\r\n    _cb = null;\r\n    throw err;\r\n  }\r\n}\r\n\r\nexport function stopRecognizer() {\r\n  try {\r\n    if (_rec) {\r\n      try { _rec.stop(); } catch {}\r\n      _rec = null;\r\n    }\r\n  } finally {\r\n    _cb = null;\r\n  }\r\n}\r\n\r\n// Attach a safe shim on window for legacy callers. Loader will import this file\r\n// and wire the functions onto window.__tpSpeech.\r\n(function attachShim() {\r\n  try {\r\n    const w: any = window as any;\r\n    w.__tpSpeech = w.__tpSpeech || {};\r\n    w.__tpSpeech.startRecognizer = startRecognizer;\r\n    w.__tpSpeech.stopRecognizer = stopRecognizer;\r\n    w.__tpSpeech.matchBatch = matchBatch;\r\n  } catch {\r\n    // noop\r\n  }\r\n})();\r\n"],
  "mappings": "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",
  "names": ["matchBatch"]
}
