{
  "version": 3,
  "sources": ["../src/speech/matcher.ts"],
  "sourcesContent": ["// Matcher: alignment, scoring and commit logic for speech-sync\r\n// This module is a conservative port/encapsulation of the inline matcher logic\r\n// found in the legacy runtime. It focuses on pure computational logic and\r\n// exposes a small procedural API the runtime can call from event handlers.\r\n\r\nexport type MatchConfig = {\r\n  MATCH_WINDOW_AHEAD: number;\r\n  MATCH_WINDOW_BACK: number;\r\n  SIM_THRESHOLD: number;\r\n  MAX_JUMP_AHEAD_WORDS: number;\r\n};\r\n\r\nexport type MatchResult = {\r\n  bestIdx: number;\r\n  bestSim: number;\r\n  topScores: Array<{ idx: number; score: number }>;\r\n};\r\n\r\n// Minimal similarity helpers (kept pure for unit testing)\r\nexport function normTokens(s: string): string[] {\r\n  // Align with sanitizeForMatch semantics: strip bracketed cues and normalize punctuation.\r\n  return String(s || '')\r\n    .toLowerCase()\r\n    .replace(/\\[[^\\]]+]/g, '')      // strip [pause]/[beat]/[note]\r\n    .replace(/[\u201C\u201D\"']/g, '')          // remove quotes\r\n    .replace(/[\u2014\u2013]/g, '-')            // normalize dashes\r\n    .replace(/[^\\w\\s-]/g, ' ')      // drop other punctuation\r\n    .replace(/\\s+/g, ' ')\r\n    .trim()\r\n    .split(' ')\r\n    .filter(Boolean);\r\n}\r\n\r\nexport function getNgrams(tokens: string[], n: number) {\r\n  const out: string[] = [];\r\n  for (let i = 0; i <= tokens.length - n; i++) out.push(tokens.slice(i, i + n).join(' '));\r\n  return out;\r\n}\r\n\r\nexport function cosineSimilarity(vec1: number[], vec2: number[]) {\r\n  let dot = 0,\r\n    n1 = 0,\r\n    n2 = 0;\r\n  for (let i = 0; i < vec1.length; i++) {\r\n    dot += vec1[i] * vec2[i];\r\n    n1 += vec1[i] * vec1[i];\r\n    n2 += vec2[i] * vec2[i];\r\n  }\r\n  return n1 && n2 ? dot / (Math.sqrt(n1) * Math.sqrt(n2)) : 0;\r\n}\r\n\r\n// Simplified TF-IDF-ish similarity using ngram counts (cheap, deterministic)\r\nexport function computeTFIDFSimilarity(tokens1: string[], tokens2: string[]) {\r\n  const ngrams1 = getNgrams(tokens1, 2).concat(getNgrams(tokens1, 3));\r\n  const ngrams2 = getNgrams(tokens2, 2).concat(getNgrams(tokens2, 3));\r\n  const all = Array.from(new Set([...ngrams1, ...ngrams2]));\r\n  const v1 = all.map((ng) => ngrams1.filter((x) => x === ng).length);\r\n  const v2 = all.map((ng) => ngrams2.filter((x) => x === ng).length);\r\n  return cosineSimilarity(v1, v2);\r\n}\r\n\r\nexport function computeJaccardSimilarity(tokens1: string[], tokens2: string[]) {\r\n  const s1 = new Set(tokens1.map((t) => t.toLowerCase()));\r\n  const s2 = new Set(tokens2.map((t) => t.toLowerCase()));\r\n  const inter = new Set([...s1].filter((x) => s2.has(x)));\r\n  const union = new Set([...s1, ...s2]);\r\n  return union.size ? inter.size / union.size : 0;\r\n}\r\n\r\nexport function computeLineSimilarity(spokenTokens: string[], scriptText: string) {\r\n  const scriptTokens = normTokens(scriptText);\r\n  const tfidf = computeTFIDFSimilarity(spokenTokens, scriptTokens);\r\n  const jacc = computeJaccardSimilarity(spokenTokens, scriptTokens);\r\n  // Simple char overlap as fallback\r\n  const charsA = spokenTokens.join(' ');\r\n  const charsB = scriptTokens.join(' ');\r\n  const charF1 = (() => {\r\n    const setA = new Set(charsA.split(''));\r\n    const setB = new Set(charsB.split(''));\r\n    const inter = new Set([...setA].filter((x) => setB.has(x)));\r\n    const p = setA.size ? inter.size / setA.size : 0;\r\n    const r = setB.size ? inter.size / setB.size : 0;\r\n    return p + r > 0 ? (2 * p * r) / (p + r) : 0;\r\n  })();\r\n\r\n  let score = 0.5 * tfidf + 0.3 * charF1 + 0.2 * jacc;\r\n  if (scriptTokens.length < 5) score -= 0.12;\r\n  return Math.max(0, Math.min(1, score));\r\n}\r\n\r\n// Top-level matching API. It expects precomputed scriptWords and paraIndex\r\n// from the runtime and returns the best match for the spoken token batch.\r\nexport function matchBatch(\r\n  spokenTokens: string[],\r\n  scriptWords: string[],\r\n  paraIndex: Array<{ start: number; end: number; key: string; isMeta?: boolean; isNonSpoken?: boolean }>,\r\n  vParaIndex: string[] | null,\r\n  cfg: MatchConfig,\r\n  currentIndex: number,\r\n  _viterbiState?: { path: number[]; pred?: number }\r\n): MatchResult {\r\n  const batch = spokenTokens.slice(-Math.max(3, spokenTokens.length));\r\n  const candidates = new Set<number>();\r\n  const windowAhead = cfg.MATCH_WINDOW_AHEAD;\r\n\r\n  const candidateStart = Math.max(0, Math.floor(currentIndex) - cfg.MATCH_WINDOW_BACK);\r\n  const candidateEnd = Math.min(scriptWords.length - 1, Math.floor(currentIndex) + windowAhead);\r\n  for (let i = candidateStart; i <= candidateEnd; i++) candidates.add(i);\r\n\r\n  const scores: Record<number, number> = {};\r\n  const candidateArray = Array.from(candidates);\r\n  for (const j of candidateArray) {\r\n    const para = vParaIndex ? vParaIndex[j] : paraIndex[j]?.key;\r\n    if (!para) continue;\r\n    let sc = computeLineSimilarity(batch, String(para));\r\n    if (paraIndex[j]?.isMeta) sc = sc * 0.5 - 0.2;\r\n    else if (paraIndex[j]?.isNonSpoken) sc = sc - 0.6;\r\n    scores[j] = sc;\r\n  }\r\n\r\n  const top = Object.entries(scores)\r\n    .sort(([, a], [, b]) => (b as number) - (a as number))\r\n    .slice(0, 3)\r\n    .map(([idx, score]) => ({ idx: Number(idx), score: Number((score as number).toFixed(3)) }));\r\n\r\n  // Windowed matching band around the currently visible/expected line.\r\n  // Unless the top candidate is very strong (>= 0.82), prefer a candidate within \u00B140.\r\n  const radius = 40;\r\n  const bandStart = Math.max(0, Math.floor(currentIndex) - radius);\r\n  const bandEnd = Math.min((vParaIndex ? vParaIndex.length : paraIndex.length) - 1, Math.floor(currentIndex) + radius);\r\n  let best = top[0] || { idx: Math.max(0, currentIndex), score: 0 };\r\n  if (best && (best.idx < bandStart || best.idx > bandEnd) && (best.score as number) < 0.82) {\r\n    const inBand = top.find(t => t.idx >= bandStart && t.idx <= bandEnd);\r\n    if (inBand) best = inBand;\r\n  }\r\n  return { bestIdx: best.idx, bestSim: best.score as number, topScores: top };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
